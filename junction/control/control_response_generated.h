// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CONTROLRESPONSE_JUNCTION_CTL_SCHEMA_H_
#define FLATBUFFERS_GENERATED_CONTROLRESPONSE_JUNCTION_CTL_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
                  FLATBUFFERS_VERSION_MINOR == 3 &&
                  FLATBUFFERS_VERSION_REVISION == 7,
              "Non-compatible flatbuffers version included");

namespace junction {
namespace ctl_schema {

struct SuccessResponse;
struct SuccessResponseBuilder;

struct ErrorResponse;
struct ErrorResponseBuilder;

struct GetStatsResponse;
struct GetStatsResponseBuilder;

struct TracePoint;
struct TracePointBuilder;

struct TraceReport;
struct TraceReportBuilder;

struct Response;
struct ResponseBuilder;

enum InnerResponse : uint8_t {
  InnerResponse_NONE = 0,
  InnerResponse_error = 1,
  InnerResponse_genericSuccess = 2,
  InnerResponse_getStats = 3,
  InnerResponse_traceReport = 4,
  InnerResponse_MIN = InnerResponse_NONE,
  InnerResponse_MAX = InnerResponse_traceReport
};

inline const InnerResponse (&EnumValuesInnerResponse())[5] {
  static const InnerResponse values[] = {
      InnerResponse_NONE, InnerResponse_error, InnerResponse_genericSuccess,
      InnerResponse_getStats, InnerResponse_traceReport};
  return values;
}

inline const char *const *EnumNamesInnerResponse() {
  static const char *const names[6] = {
      "NONE", "error", "genericSuccess", "getStats", "traceReport", nullptr};
  return names;
}

inline const char *EnumNameInnerResponse(InnerResponse e) {
  if (::flatbuffers::IsOutRange(e, InnerResponse_NONE,
                                InnerResponse_traceReport))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInnerResponse()[index];
}

template <typename T>
struct InnerResponseTraits {
  static const InnerResponse enum_value = InnerResponse_NONE;
};

template <>
struct InnerResponseTraits<junction::ctl_schema::ErrorResponse> {
  static const InnerResponse enum_value = InnerResponse_error;
};

template <>
struct InnerResponseTraits<junction::ctl_schema::SuccessResponse> {
  static const InnerResponse enum_value = InnerResponse_genericSuccess;
};

template <>
struct InnerResponseTraits<junction::ctl_schema::GetStatsResponse> {
  static const InnerResponse enum_value = InnerResponse_getStats;
};

template <>
struct InnerResponseTraits<junction::ctl_schema::TraceReport> {
  static const InnerResponse enum_value = InnerResponse_traceReport;
};

bool VerifyInnerResponse(::flatbuffers::Verifier &verifier, const void *obj,
                         InnerResponse type);
bool VerifyInnerResponseVector(
    ::flatbuffers::Verifier &verifier,
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
    const ::flatbuffers::Vector<uint8_t> *types);

struct SuccessResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SuccessResponseBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SuccessResponseBuilder {
  typedef SuccessResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SuccessResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SuccessResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SuccessResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SuccessResponse> CreateSuccessResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SuccessResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ErrorResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4
  };
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  ::flatbuffers::String *mutable_message() {
    return GetPointer<::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) && verifier.EndTable();
  }
};

struct ErrorResponseBuilder {
  typedef ErrorResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ErrorResponse::VT_MESSAGE, message);
  }
  explicit ErrorResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ErrorResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ErrorResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ErrorResponse> CreateErrorResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ErrorResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ErrorResponse> CreateErrorResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return junction::ctl_schema::CreateErrorResponse(_fbb, message__);
}

struct GetStatsResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetStatsResponseBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct GetStatsResponseBuilder {
  typedef GetStatsResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GetStatsResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetStatsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetStatsResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetStatsResponse> CreateGetStatsResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GetStatsResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TracePoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TracePointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP_US = 4,
    VT_ACCESSED_LOCATION = 6,
    VT_TYPE_STR = 8
  };
  uint64_t timestamp_us() const {
    return GetField<uint64_t>(VT_TIMESTAMP_US, 0);
  }
  bool mutate_timestamp_us(uint64_t _timestamp_us = 0) {
    return SetField<uint64_t>(VT_TIMESTAMP_US, _timestamp_us, 0);
  }
  uint64_t accessed_location() const {
    return GetField<uint64_t>(VT_ACCESSED_LOCATION, 0);
  }
  bool mutate_accessed_location(uint64_t _accessed_location = 0) {
    return SetField<uint64_t>(VT_ACCESSED_LOCATION, _accessed_location, 0);
  }
  const ::flatbuffers::String *type_str() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE_STR);
  }
  ::flatbuffers::String *mutable_type_str() {
    return GetPointer<::flatbuffers::String *>(VT_TYPE_STR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP_US, 8) &&
           VerifyField<uint64_t>(verifier, VT_ACCESSED_LOCATION, 8) &&
           VerifyOffset(verifier, VT_TYPE_STR) &&
           verifier.VerifyString(type_str()) && verifier.EndTable();
  }
};

struct TracePointBuilder {
  typedef TracePoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp_us(uint64_t timestamp_us) {
    fbb_.AddElement<uint64_t>(TracePoint::VT_TIMESTAMP_US, timestamp_us, 0);
  }
  void add_accessed_location(uint64_t accessed_location) {
    fbb_.AddElement<uint64_t>(TracePoint::VT_ACCESSED_LOCATION,
                              accessed_location, 0);
  }
  void add_type_str(::flatbuffers::Offset<::flatbuffers::String> type_str) {
    fbb_.AddOffset(TracePoint::VT_TYPE_STR, type_str);
  }
  explicit TracePointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TracePoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TracePoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TracePoint> CreateTracePoint(
    ::flatbuffers::FlatBufferBuilder &_fbb, uint64_t timestamp_us = 0,
    uint64_t accessed_location = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type_str = 0) {
  TracePointBuilder builder_(_fbb);
  builder_.add_accessed_location(accessed_location);
  builder_.add_timestamp_us(timestamp_us);
  builder_.add_type_str(type_str);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TracePoint> CreateTracePointDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, uint64_t timestamp_us = 0,
    uint64_t accessed_location = 0, const char *type_str = nullptr) {
  auto type_str__ = type_str ? _fbb.CreateString(type_str) : 0;
  return junction::ctl_schema::CreateTracePoint(_fbb, timestamp_us,
                                                accessed_location, type_str__);
}

struct TraceReport FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TraceReportBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOTAL_PAGES = 4,
    VT_NON_ZERO_PAGES = 6,
    VT_ACCESSED_US = 8
  };
  uint64_t total_pages() const { return GetField<uint64_t>(VT_TOTAL_PAGES, 0); }
  bool mutate_total_pages(uint64_t _total_pages = 0) {
    return SetField<uint64_t>(VT_TOTAL_PAGES, _total_pages, 0);
  }
  uint64_t non_zero_pages() const {
    return GetField<uint64_t>(VT_NON_ZERO_PAGES, 0);
  }
  bool mutate_non_zero_pages(uint64_t _non_zero_pages = 0) {
    return SetField<uint64_t>(VT_NON_ZERO_PAGES, _non_zero_pages, 0);
  }
  const ::flatbuffers::Vector<
      ::flatbuffers::Offset<junction::ctl_schema::TracePoint>> *
  accessed_us() const {
    return GetPointer<const ::flatbuffers::Vector<
        ::flatbuffers::Offset<junction::ctl_schema::TracePoint>> *>(
        VT_ACCESSED_US);
  }
  ::flatbuffers::Vector<
      ::flatbuffers::Offset<junction::ctl_schema::TracePoint>> *
  mutable_accessed_us() {
    return GetPointer<::flatbuffers::Vector<
        ::flatbuffers::Offset<junction::ctl_schema::TracePoint>> *>(
        VT_ACCESSED_US);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TOTAL_PAGES, 8) &&
           VerifyField<uint64_t>(verifier, VT_NON_ZERO_PAGES, 8) &&
           VerifyOffset(verifier, VT_ACCESSED_US) &&
           verifier.VerifyVector(accessed_us()) &&
           verifier.VerifyVectorOfTables(accessed_us()) && verifier.EndTable();
  }
};

struct TraceReportBuilder {
  typedef TraceReport Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_total_pages(uint64_t total_pages) {
    fbb_.AddElement<uint64_t>(TraceReport::VT_TOTAL_PAGES, total_pages, 0);
  }
  void add_non_zero_pages(uint64_t non_zero_pages) {
    fbb_.AddElement<uint64_t>(TraceReport::VT_NON_ZERO_PAGES, non_zero_pages,
                              0);
  }
  void add_accessed_us(
      ::flatbuffers::Offset<::flatbuffers::Vector<
          ::flatbuffers::Offset<junction::ctl_schema::TracePoint>>>
          accessed_us) {
    fbb_.AddOffset(TraceReport::VT_ACCESSED_US, accessed_us);
  }
  explicit TraceReportBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TraceReport> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TraceReport>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TraceReport> CreateTraceReport(
    ::flatbuffers::FlatBufferBuilder &_fbb, uint64_t total_pages = 0,
    uint64_t non_zero_pages = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<
        ::flatbuffers::Offset<junction::ctl_schema::TracePoint>>>
        accessed_us = 0) {
  TraceReportBuilder builder_(_fbb);
  builder_.add_non_zero_pages(non_zero_pages);
  builder_.add_total_pages(total_pages);
  builder_.add_accessed_us(accessed_us);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TraceReport> CreateTraceReportDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb, uint64_t total_pages = 0,
    uint64_t non_zero_pages = 0,
    const std::vector<::flatbuffers::Offset<junction::ctl_schema::TracePoint>>
        *accessed_us = nullptr) {
  auto accessed_us__ =
      accessed_us
          ? _fbb.CreateVector<
                ::flatbuffers::Offset<junction::ctl_schema::TracePoint>>(
                *accessed_us)
          : 0;
  return junction::ctl_schema::CreateTraceReport(_fbb, total_pages,
                                                 non_zero_pages, accessed_us__);
}

struct Response FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INNER_TYPE = 4,
    VT_INNER = 6
  };
  junction::ctl_schema::InnerResponse inner_type() const {
    return static_cast<junction::ctl_schema::InnerResponse>(
        GetField<uint8_t>(VT_INNER_TYPE, 0));
  }
  const void *inner() const { return GetPointer<const void *>(VT_INNER); }
  template <typename T>
  const T *inner_as() const;
  const junction::ctl_schema::ErrorResponse *inner_as_error() const {
    return inner_type() == junction::ctl_schema::InnerResponse_error
               ? static_cast<const junction::ctl_schema::ErrorResponse *>(
                     inner())
               : nullptr;
  }
  const junction::ctl_schema::SuccessResponse *inner_as_genericSuccess() const {
    return inner_type() == junction::ctl_schema::InnerResponse_genericSuccess
               ? static_cast<const junction::ctl_schema::SuccessResponse *>(
                     inner())
               : nullptr;
  }
  const junction::ctl_schema::GetStatsResponse *inner_as_getStats() const {
    return inner_type() == junction::ctl_schema::InnerResponse_getStats
               ? static_cast<const junction::ctl_schema::GetStatsResponse *>(
                     inner())
               : nullptr;
  }
  const junction::ctl_schema::TraceReport *inner_as_traceReport() const {
    return inner_type() == junction::ctl_schema::InnerResponse_traceReport
               ? static_cast<const junction::ctl_schema::TraceReport *>(inner())
               : nullptr;
  }
  void *mutable_inner() { return GetPointer<void *>(VT_INNER); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INNER_TYPE, 1) &&
           VerifyOffset(verifier, VT_INNER) &&
           VerifyInnerResponse(verifier, inner(), inner_type()) &&
           verifier.EndTable();
  }
};

template <>
inline const junction::ctl_schema::ErrorResponse *
Response::inner_as<junction::ctl_schema::ErrorResponse>() const {
  return inner_as_error();
}

template <>
inline const junction::ctl_schema::SuccessResponse *
Response::inner_as<junction::ctl_schema::SuccessResponse>() const {
  return inner_as_genericSuccess();
}

template <>
inline const junction::ctl_schema::GetStatsResponse *
Response::inner_as<junction::ctl_schema::GetStatsResponse>() const {
  return inner_as_getStats();
}

template <>
inline const junction::ctl_schema::TraceReport *
Response::inner_as<junction::ctl_schema::TraceReport>() const {
  return inner_as_traceReport();
}

struct ResponseBuilder {
  typedef Response Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_inner_type(junction::ctl_schema::InnerResponse inner_type) {
    fbb_.AddElement<uint8_t>(Response::VT_INNER_TYPE,
                             static_cast<uint8_t>(inner_type), 0);
  }
  void add_inner(::flatbuffers::Offset<void> inner) {
    fbb_.AddOffset(Response::VT_INNER, inner);
  }
  explicit ResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response> CreateResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    junction::ctl_schema::InnerResponse inner_type =
        junction::ctl_schema::InnerResponse_NONE,
    ::flatbuffers::Offset<void> inner = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_inner(inner);
  builder_.add_inner_type(inner_type);
  return builder_.Finish();
}

inline bool VerifyInnerResponse(::flatbuffers::Verifier &verifier,
                                const void *obj, InnerResponse type) {
  switch (type) {
    case InnerResponse_NONE: {
      return true;
    }
    case InnerResponse_error: {
      auto ptr =
          reinterpret_cast<const junction::ctl_schema::ErrorResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InnerResponse_genericSuccess: {
      auto ptr =
          reinterpret_cast<const junction::ctl_schema::SuccessResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InnerResponse_getStats: {
      auto ptr =
          reinterpret_cast<const junction::ctl_schema::GetStatsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InnerResponse_traceReport: {
      auto ptr =
          reinterpret_cast<const junction::ctl_schema::TraceReport *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool VerifyInnerResponseVector(
    ::flatbuffers::Verifier &verifier,
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
    const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyInnerResponse(verifier, values->Get(i),
                             types->GetEnum<InnerResponse>(i))) {
      return false;
    }
  }
  return true;
}

inline const junction::ctl_schema::Response *GetResponse(const void *buf) {
  return ::flatbuffers::GetRoot<junction::ctl_schema::Response>(buf);
}

inline const junction::ctl_schema::Response *GetSizePrefixedResponse(
    const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<junction::ctl_schema::Response>(
      buf);
}

inline Response *GetMutableResponse(void *buf) {
  return ::flatbuffers::GetMutableRoot<Response>(buf);
}

inline junction::ctl_schema::Response *GetMutableSizePrefixedResponse(
    void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<
      junction::ctl_schema::Response>(buf);
}

inline bool VerifyResponseBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<junction::ctl_schema::Response>(nullptr);
}

inline bool VerifySizePrefixedResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<junction::ctl_schema::Response>(
      nullptr);
}

inline void FinishResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<junction::ctl_schema::Response> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<junction::ctl_schema::Response> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace ctl_schema
}  // namespace junction

#endif  // FLATBUFFERS_GENERATED_CONTROLRESPONSE_JUNCTION_CTL_SCHEMA_H_
