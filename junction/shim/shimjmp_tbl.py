#!/usr/bin/env python3

import sys
import os

assert len(sys.argv) == 4

SHIMCALL_HDR = sys.argv[1]
OUTPUT_FILE_TBL = sys.argv[2]
OUTPUT_FILE_SHIM = sys.argv[3]


def parse_enum():
	with open(SHIMCALL_HDR) as f:
		dat = f.read()

	names = {}
	enums = dat.split("enum : size_t {")[1].split("}", 2)[0].split(",")
	for idx, enum in enumerate(enums):
		enum = enum.strip()
		if not enum: continue
		name = enum.split()[0].rstrip(",")
		names[name] = idx
	return names


jmpfns = parse_enum()

assert int(jmpfns["NR_SHIM_CALL"]) == len(jmpfns) - 1
del jmpfns["NR_SHIM_CALL"]

filename = os.path.basename(OUTPUT_FILE_TBL)
dispatch_file = [f"// {filename} - Generated by shimjmptbl.py - do not modify", "", ""]
dispatch_file += ["#include \"junction/shim/shim.h\""]

dispatch_file += ["namespace junction {"]

dispatch_file += [f"void *shim_jmptbl[{len(jmpfns)}] = {'{'}"]
for name, idx in jmpfns.items():
	dispatch_file.append(f"\t[{idx}] = reinterpret_cast<void *>(&junction::shim_{name}),")
dispatch_file.append("};")

# finish file and write it out
dispatch_file.append("}  // namespace junction")

with open(OUTPUT_FILE_TBL, "w") as f:
	f.write("\n".join(dispatch_file))

filename = os.path.basename(OUTPUT_FILE_SHIM)
with open(OUTPUT_FILE_SHIM, "w") as f:
	f.write(f"// {filename} - Generated by shimjmptbl.py - do not modify\n\n")
	for name, idx in jmpfns.items():
		# if "_stack" not in name: continue
		f.write(f".globl {name}\n")
		f.write(f".type {name}, @function\n")
		f.write(f"{name}:\n")
		f.write(f"jmp *({0x202000 + 8 * idx})\n\n")
