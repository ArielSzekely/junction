#!/usr/bin/env python3

import sys
import os

assert len(sys.argv) == 3

USYS_LIST = sys.argv[1]
OUTPUT_FILE = sys.argv[2]

SYS_NR = 453
REAL_SYS_NR = 451

TF_SAVE_SYSCALLS = set(["clone3", "clone"])

# Header files scanned in the given order to get a list of syscall numbers.
# The first file found is used.
SYSCALL_DEFS_FILES = [
	"/usr/include/asm/unistd_64.h",
	"/usr/include/x86_64-linux-gnu/asm/unistd_64.h"
]

STRACE_ARGS_THAT_ARE_PATHNAMES = set([
	("openat", 1),
	("open", 0),
	("access", 0),
	("readlink", 0),
	("readlinkat", 1),
	("newfstatat", 1),
	("stat", 0),
	("statfs", 0),
	("mkdir", 0),
	("mkdirat", 1),
	("rmdir", 0),
	("link", 0),
	("link", 1),
	("unlink", 0),
	("chown", 0),
	("chmod", 0),
])

def emit_strace_target(strace_name, name, output):
		fn = f"\nextern \"C\" uint64_t {name}_trace(uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5) {'{'}"
		fn += f"\n\tuint64_t ret = reinterpret_cast<sysfn_t>(&{name})(arg0, arg1, arg2, arg3, arg4, arg5);"
		fn += f"\n\tLOG(INFO) << \"{strace_name}(\""
		for i in range(6):
			if (strace_name, i) not in STRACE_ARGS_THAT_ARE_PATHNAMES:
				fn += f"\n\t\t  << reinterpret_cast<void *>(arg{i})"
			else:
				fn += f"\n\t\t  << reinterpret_cast<char *>(arg{i})"
			if i < 5:
				fn += " << \", \""
		fn += "\n\t\t  << \") = \"" + " << static_cast<long>(ret);"
		fn += "\n\treturn ret;"
		fn += "\n}"
		output.append(fn)

def emit_enosys_target(function_name, sysnr, syscall_name, output):
		fn = f"\nextern \"C\" long {function_name}(long arg0, long arg1, long arg2, long arg3, long arg4, long arg5) {'{'}"
		fn += f"\n\tLOG_ONCE(ERR) << \"Unsupported system call {sysnr}:{syscall_name}\";"
		fn += "\n\treturn -ENOSYS;"
		fn += "\n}"
		output.append(fn)

def emit_forward_target(function_name, sysnr, output):
		fn = f"\nextern \"C\" long {function_name}(long arg0, long arg1, long arg2, long arg3, long arg4, long arg5) {'{'}"
		fn += f"\n\treturn ksys_default(arg0, arg1, arg2, arg3, arg4, arg5, {sysnr});"
		fn += "\n}"
		output.append(fn)

def gen_syscall_dict():
	syscall_defs_file = None
	for file in SYSCALL_DEFS_FILES:
		if os.path.exists(file):
			syscall_defs_file = file
			break
	assert (syscall_defs_file is not None), "No header file found for determining syscall numbers"
	with open(syscall_defs_file) as f:
		dat = f.read().splitlines()
	syscall_nr_to_name = {}
	syscall_name_to_nr = {}
	for line in dat:
		ls = line.strip().split("#define __NR_")
		if len(ls) > 1:
			name, nr = ls[1].split()
			syscall_nr_to_name[int(nr)] = name
			syscall_name_to_nr[name] = int(nr)
	return syscall_nr_to_name, syscall_name_to_nr

def gen_usys_list():
	with open(USYS_LIST) as f:
		for line in f:
			line = line.strip()
			if not line or line.startswith("#"):
				continue
			yield line

syscall_nr_to_name, syscall_name_to_nr = gen_syscall_dict()

filename = os.path.basename(OUTPUT_FILE)
dispatch_file = [f"// {filename} - Generated by systbl.py - do not modify", "", ""]
dispatch_file += ["#include \"junction/syscall/systbl.h\"", "#include \"junction/bindings/log.h\""]
dispatch_file += ["#include \"junction/syscall/syscall.h\"",]
dispatch_file += [f"static_assert(SYS_NR == {SYS_NR});"] # Make sure we are in sync with the header
dispatch_file += ["namespace junction {"]

defined_syscalls = [None for i in range(SYS_NR)]

fwded_calls = set()

for name in gen_usys_list():
	ns = name.split(":::", 2)
	name = ns[0]
	if name not in syscall_name_to_nr:
		continue
	if len(ns) > 1 and ns[1] == "fwd":
		fwded_calls.add(syscall_name_to_nr.get(name))
	else:
		nr = syscall_name_to_nr.get(name)
		if name in TF_SAVE_SYSCALLS: name += "_enter"
		defined_syscalls[nr] = f"junction::usys_{name}"

defined_syscalls[451] = f"junction::junction_fncall_stackswitch_enter"
defined_syscalls[452] = "junction::junction_fncall_stackswitch_clone_enter"

# generate stub functions for unimplemented, forwarded, and strace syscalls
for i, entry in enumerate(defined_syscalls):

	name = syscall_nr_to_name.get(i, str(i))

	if i in fwded_calls:
		defined_syscalls[i] = f"usys_{name}_fwd"
		emit_forward_target(defined_syscalls[i], i, dispatch_file)
	elif not entry:
		defined_syscalls[i] = f"usys_{name}_enosys"
		emit_enosys_target(defined_syscalls[i], i, name, dispatch_file)
	else:
		# do nothing, junction defines this target
		pass

	if i < REAL_SYS_NR:
		emit_strace_target(name, defined_syscalls[i].split("::")[-1], dispatch_file)

# generate the sysfn table
dispatch_file += [f"sysfn_t sys_tbl[SYS_NR] = {'{'}"]
for i, entry in enumerate(defined_syscalls):
	idx = f"SYS_{syscall_nr_to_name[i]}" if i in syscall_nr_to_name else i
	dispatch_file.append(f"\t[{idx}] = reinterpret_cast<sysfn_t>(&{entry}),")
dispatch_file.append("};")

# generate the table of names for debugging
dispatch_file += [f"const char *syscall_names[SYS_NR] = {'{'}"]
for i, entry in enumerate(defined_syscalls):
	idx = f"SYS_{syscall_nr_to_name[i]}" if i in syscall_nr_to_name else i
	name = syscall_nr_to_name.get(i, f"unknown_syscall_{i}")
	dispatch_file.append(f"\t[{idx}] = \"{name}\",")
dispatch_file.append("};")

# generate the sysfn-strace table
dispatch_file += [f"sysfn_t sys_tbl_strace[SYS_NR] = {'{'}"]
for i, entry in enumerate(defined_syscalls):
	if i >= REAL_SYS_NR: continue
	idx = f"SYS_{syscall_nr_to_name[i]}" if i in syscall_nr_to_name else i
	if entry.endswith("_enter"):
		name = entry
	else:
		name = entry.split("::")[-1] + "_trace"
	dispatch_file.append(f"\t[{idx}] = reinterpret_cast<sysfn_t>(&{name}),")
dispatch_file.append("};")

# finish file and write it out
dispatch_file.append("}  // namespace junction")

with open(OUTPUT_FILE, "w") as f:
	f.write("\n".join(dispatch_file))

