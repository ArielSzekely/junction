#!/usr/bin/env python3

import sys
import os

assert len(sys.argv) == 3

USYS_LIST = sys.argv[1]
OUTPUT_FILE = sys.argv[2]

SYS_NR = 451

TF_SAVE_SYSCALLS = set(["clone3", "clone"])

# Header files scanned in the given order to get a list of syscall numbers.
# The first file found is used.
SYSCALL_DEFS_FILES = [
	"/usr/include/asm/unistd_64.h",
	"/usr/include/x86_64-linux-gnu/asm/unistd_64.h"
]

def gen_syscall_dict():
	syscall_defs_file = None
	for file in SYSCALL_DEFS_FILES:
		if os.path.exists(file):
			syscall_defs_file = file
			break
	assert (syscall_defs_file is not None), "No header file found for determining syscall numbers"
	with open(syscall_defs_file) as f:
		dat = f.read().splitlines()
	syscall_nr_to_name = {}
	syscall_name_to_nr = {}
	for line in dat:
		ls = line.strip().split("#define __NR_")
		if len(ls) > 1:
			name, nr = ls[1].split()
			syscall_nr_to_name[int(nr)] = name
			syscall_name_to_nr[name] = int(nr)
	return syscall_nr_to_name, syscall_name_to_nr

def gen_usys_list():
	with open(USYS_LIST) as f:
		for line in f:
			line = line.strip()
			if not line or line.startswith("#"):
				continue
			yield line

syscall_nr_to_name, syscall_name_to_nr = gen_syscall_dict()

filename = os.path.basename(OUTPUT_FILE)
dispatch_file = [f"// {filename} - Generated by systbl.py - do not modify", "", ""]
dispatch_file += ["#include \"junction/syscall/systbl.h\"", "#include \"junction/bindings/log.h\""]
dispatch_file += ["#include \"junction/syscall/syscall.h\"",]
dispatch_file += [f"static_assert(SYS_NR == {SYS_NR});"] # Make sure we are in sync with the header
dispatch_file += ["namespace junction {"]

defined_syscalls = [None for i in range(SYS_NR)]

for name in gen_usys_list():
	ns = name.split(":::", 2)
	name = ns[0]
	if name not in syscall_name_to_nr:
		continue
	if len(ns) > 1 and ns[1] == "enosys":
		defined_syscalls[syscall_name_to_nr.get(name)] = f"junction::usys_enosys"
	else:
		nr = syscall_name_to_nr.get(name)
		if name in TF_SAVE_SYSCALLS: name += "_enter"
		defined_syscalls[nr] = f"junction::usys_{name}"

# generate stub functions for unimplemented syscalls
# TODO: eventually replace these with a single function
for i, entry in enumerate(defined_syscalls):
	if entry: continue
	name = syscall_nr_to_name.get(i, str(i))
	fn = f"""
extern "C" {'{'} long usys_{name}_fwd(long arg0, long arg1, long arg2, long arg3, long arg4, long arg5) {'{'}
  LOG_ONCE(ERR) << "Unsupported system call {i}:{name}";
  return -ENOSYS;
{'}'}{'}'}"""
	dispatch_file.append(fn)

# generate the sysfn table
dispatch_file += [f"sysfn_t sys_tbl[SYS_NR] = {'{'}"]
for i, entry in enumerate(defined_syscalls):
	idx = f"SYS_{syscall_nr_to_name[i]}" if i in syscall_nr_to_name else i
	if not entry:
		name = syscall_nr_to_name.get(i, str(i))
		entry = f"usys_{name}_fwd"
	dispatch_file.append(f"\t[{idx}] = reinterpret_cast<sysfn_t>(&{entry}),")
dispatch_file.append("};")

# generate the table of names for debugging
dispatch_file += [f"const char *syscall_names[SYS_NR] = {'{'}"]
for i, entry in enumerate(defined_syscalls):
	idx = f"SYS_{syscall_nr_to_name[i]}" if i in syscall_nr_to_name else i
	name = syscall_nr_to_name.get(i, f"unknown_syscall_{i}")
	dispatch_file.append(f"\t[{idx}] = \"{name}\",")
dispatch_file.append("};")

# finish file and write it out
dispatch_file.append("}  // namespace junction")

with open(OUTPUT_FILE, "w") as f:
	f.write("\n".join(dispatch_file))

