From 9927043c204ed1a1f661da099d828a755ad3df16 Mon Sep 17 00:00:00 2001
From: Gohar Irfan Chaudhry <girfan@mit.edu>
Date: Mon, 17 Oct 2022 22:12:01 +0000
Subject: [PATCH 1/2] junction sycall interception hooks

---
 Makeconfig                                  |  4 +-
 Makefile                                    |  2 +-
 elf/Makefile                                |  6 +-
 junction/Makefile                           | 31 ++++++++
 junction/junction_syscall.c                 | 46 ++++++++++++
 junction/junction_syscall.h                 | 20 ++++++
 nscd/Makefile                               |  1 +
 sysdeps/unix/sysdep.h                       | 13 +++-
 sysdeps/unix/sysv/linux/clock_adjtime.c     |  2 +-
 sysdeps/unix/sysv/linux/nscd_setup_thread.c |  1 -
 sysdeps/unix/sysv/linux/x86_64/Makefile     |  4 ++
 sysdeps/unix/sysv/linux/x86_64/sysdep.h     | 80 +++++++++++++++++++++
 12 files changed, 201 insertions(+), 9 deletions(-)
 create mode 100644 junction/Makefile
 create mode 100644 junction/junction_syscall.c
 create mode 100644 junction/junction_syscall.h

diff --git a/Makeconfig b/Makeconfig
index 842f49eb58..b4fc59465a 100644
--- a/Makeconfig
+++ b/Makeconfig
@@ -376,7 +376,9 @@ endif
 
 relro-LDFLAGS = -Wl,-z,relro
 LDFLAGS.so += $(relro-LDFLAGS)
+LDFLAGS.so += -Wl,-z,lazy -Wl,--unresolved-symbols=ignore-all
 LDFLAGS-rtld += $(relro-LDFLAGS)
+LDFLAGS-rtld += -Wl,-z,lazy -Wl,--unresolved-symbols=ignore-all
 
 # Linker options to enable and disable DT_RELR.
 ifeq ($(have-dt-relr),yes)
@@ -1331,7 +1333,7 @@ endif
 # This is a partial list of subdirectories containing the library source.
 # The order is more or less arbitrary.  The sorting step will take care of the
 # dependencies and generate sorted-subdirs dynamically.
-all-subdirs = csu assert ctype locale intl catgets math setjmp signal	    \
+all-subdirs = junction csu assert ctype locale intl catgets math setjmp signal	    \
 	      stdlib stdio-common libio malloc string wcsmbs time dirent    \
 	      grp pwd posix io termios resource misc socket sysvipc gmon    \
 	      gnulib iconv iconvdata wctype manual shadow gshadow po argp   \
diff --git a/Makefile b/Makefile
index 179dd478ff..58f2edf3fa 100644
--- a/Makefile
+++ b/Makefile
@@ -58,7 +58,7 @@ endif # $(AUTOCONF) = no
 .NOTPARALLEL:
 
 # These are the targets that are made by making them in each subdirectory.
-+subdir_targets	:= subdir_lib objects objs others subdir_mostlyclean	\
++subdir_targets	:= subdir_lib objects objs subdir_mostlyclean	\
 		   subdir_clean subdir_distclean subdir_realclean	\
 		   tests xtests						\
 		   subdir_update-abi subdir_check-abi			\
diff --git a/elf/Makefile b/elf/Makefile
index 7b50ccc07a..5c256db03b 100644
--- a/elf/Makefile
+++ b/elf/Makefile
@@ -1336,10 +1336,8 @@ $(objpfx)ld.so: $(objpfx)librtld.os $(ld-map)
 		  $(LDFLAGS-rtld) -Wl,-z,defs $(z-now-$(bind-now))	\
 		  $(dt-relr-ldflag) \
 		  $(filter-out $(map-file),$^) $(load-map-file)		\
-		  -Wl,-soname=$(rtld-installed-name)
-	$(call after-link,$@.new)
-	$(READELF) -s $@.new \
-	  | $(AWK) '($$7 ~ /^UND(|EF)$$/ && $$1 != "0:" && $$4 != "REGISTER") { print; p=1 } END { exit p != 0 }'
+		  -Wl,-soname=$(rtld-installed-name) \
+      -Wl,-z,lazy -Wl,--unresolved-symbols=ignore-all
 	mv -f $@.new $@
 
 ifeq (yes,$(build-shared))
diff --git a/junction/Makefile b/junction/Makefile
new file mode 100644
index 0000000000..95f20150eb
--- /dev/null
+++ b/junction/Makefile
@@ -0,0 +1,31 @@
+# Copyright (C) 1991-2022 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, see
+# <https://www.gnu.org/licenses/>.
+
+#
+#	Sub-makefile for junction portion of the library.
+#
+objdir := junction
+
+include ../Makeconfig
+
+headers := junction_syscall.h
+
+routines := junction_syscall
+
+$(common-objpfx)junction_syscall.d: junction_syscall
+
+include ../Rules
diff --git a/junction/junction_syscall.c b/junction/junction_syscall.c
new file mode 100644
index 0000000000..35c1193856
--- /dev/null
+++ b/junction/junction_syscall.c
@@ -0,0 +1,46 @@
+#include "junction_syscall.h"
+
+#if !IS_IN(libc)
+int
+junction_syscall0 (int number)
+{
+  __set_errno (EINVAL);
+  return JUNCTION_ERROR;
+}
+
+int
+junction_syscall1 (int number, long arg1)
+{
+  return JUNCTION_ERROR;
+}
+
+int
+junction_syscall2 (int number, long arg1, long arg2)
+{
+  return JUNCTION_ERROR;
+}
+
+int
+junction_syscall3 (int number, long arg1, long arg2, long arg3)
+{
+  return JUNCTION_ERROR;
+}
+
+int
+junction_syscall4 (int number, long arg1, long arg2, long arg3, long arg4)
+{
+  return JUNCTION_ERROR;
+}
+
+int
+junction_syscall5 (int number, long arg1, long arg2, long arg3, long arg4, long arg5)
+{
+  return JUNCTION_ERROR;
+}
+
+int
+junction_syscall6 (int number, long arg1, long arg2, long arg3, long arg4, long arg5, long arg6)
+{
+  return JUNCTION_ERROR;
+}
+#endif
\ No newline at end of file
diff --git a/junction/junction_syscall.h b/junction/junction_syscall.h
new file mode 100644
index 0000000000..096a8032fb
--- /dev/null
+++ b/junction/junction_syscall.h
@@ -0,0 +1,20 @@
+#ifndef _JUNCTION_SYSCALL_H
+#define _JUNCTION_SYSCALL_H 1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#define JUNCTION_ERROR -1
+
+extern unsigned long int junction_syscall0 (int number);
+extern unsigned long int junction_syscall1 (int number, long arg1);
+extern unsigned long int junction_syscall2 (int number, long arg1, long arg2);
+extern unsigned long int junction_syscall3 (int number, long arg1, long arg2, long arg3);
+extern unsigned long int junction_syscall4 (int number, long arg1, long arg2, long arg3, long arg4);
+extern unsigned long int junction_syscall5 (int number, long arg1, long arg2, long arg3, long arg4, long arg5);
+extern unsigned long int junction_syscall6 (int number, long arg1, long arg2, long arg3, long arg4, long arg5, long arg6);
+
+__END_DECLS
+
+#endif /* _JUNCTION_SYSCALL_H */
\ No newline at end of file
diff --git a/nscd/Makefile b/nscd/Makefile
index 001794136c..dd9334a968 100644
--- a/nscd/Makefile
+++ b/nscd/Makefile
@@ -94,6 +94,7 @@ cpp-srcs-left := $(nscd-modules)
 lib := nscd
 include $(patsubst %,$(..)libof-iterator.mk,$(cpp-srcs-left))
 
+# TODO(girfan): Is there a better way to put a dependency on junctionsyscall.o?
 $(objpfx)nscd: $(nscd-modules:%=$(objpfx)%.o)
 
 ifeq ($(build-shared),yes)
diff --git a/sysdeps/unix/sysdep.h b/sysdeps/unix/sysdep.h
index a1d9df4c73..d764e9f2ef 100644
--- a/sysdeps/unix/sysdep.h
+++ b/sysdeps/unix/sysdep.h
@@ -171,5 +171,16 @@
 /* Wrappers around system calls should normally inline the system call code.
    But sometimes it is not possible or implemented and we use this code.  */
 #ifndef INLINE_SYSCALL
-#define INLINE_SYSCALL(name, nr, args...) __syscall_##name (args)
+/* TODO(girfan): Fix this to do proper argument passing to junctionsyscall. */
+#include <junction/junctionsyscall.h>
+#define INLINE_SYSCALL(name, nr, args...) \
+({ \
+  unsigned long int resultvar;					\
+  const int status = junctionsyscall(__NR_##name, nr, &resultvar); \
+  if (status == STATUS_FWD_TO_KERNEL) \
+  { \
+    resultvar = __syscall_##name (args); \
+  } \
+  (long int) resultvar; \
+})
 #endif
diff --git a/sysdeps/unix/sysv/linux/clock_adjtime.c b/sysdeps/unix/sysv/linux/clock_adjtime.c
index 5ded82f506..dc7828639c 100644
--- a/sysdeps/unix/sysv/linux/clock_adjtime.c
+++ b/sysdeps/unix/sysv/linux/clock_adjtime.c
@@ -19,9 +19,9 @@
 #include <errno.h>
 #include <stdlib.h>
 #include <time.h>
-#include <sysdep.h>
 #include <sys/timex.h>
 #include <kernel-features.h>
+#include <sysdep.h>
 
 int
 __clock_adjtime64 (const clockid_t clock_id, struct __timex64 *tx64)
diff --git a/sysdeps/unix/sysv/linux/nscd_setup_thread.c b/sysdeps/unix/sysv/linux/nscd_setup_thread.c
index bfd0aa0e05..2f5c4cf462 100644
--- a/sysdeps/unix/sysv/linux/nscd_setup_thread.c
+++ b/sysdeps/unix/sysv/linux/nscd_setup_thread.c
@@ -20,7 +20,6 @@
 #include <nscd.h>
 #include <sysdep.h>
 
-
 int
 setup_thread (struct database_dyn *db)
 {
diff --git a/sysdeps/unix/sysv/linux/x86_64/Makefile b/sysdeps/unix/sysv/linux/x86_64/Makefile
index 5e19202ebf..4403a39f06 100644
--- a/sysdeps/unix/sysv/linux/x86_64/Makefile
+++ b/sysdeps/unix/sysv/linux/x86_64/Makefile
@@ -2,6 +2,10 @@ ifeq ($(subdir),misc)
 sysdep_routines += ioperm iopl
 endif
 
+# ifeq ($(subdir),junction)
+# sysdep_routines += junctionsyscall
+# endif
+
 ifeq ($(subdir),stdlib)
 sysdep_routines += __start_context
 endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/sysdep.h b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
index 740abefcfd..3353b8f071 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sysdep.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
@@ -217,6 +217,8 @@
 
 #else	/* !__ASSEMBLER__ */
 
+#include <junction/junction_syscall.h>
+
 /* Registers clobbered by syscall.  */
 # define REGISTERS_CLOBBERED_BY_SYSCALL "cc", "r11", "cx"
 
@@ -239,6 +241,13 @@
 	internal_syscall##nr (number, args)
 
 #undef internal_syscall0
+#if IS_IN(libc)
+#define internal_syscall0(number, dummy...)				\
+({									\
+    unsigned long int res = junction_syscall0 (number); \
+    (long int) res;						\
+})
+#else
 #define internal_syscall0(number, dummy...)				\
 ({									\
     unsigned long int resultvar;					\
@@ -249,8 +258,18 @@
     : "memory", REGISTERS_CLOBBERED_BY_SYSCALL);			\
     (long int) resultvar;						\
 })
+#endif
+
 
 #undef internal_syscall1
+#if IS_IN(libc)
+#define internal_syscall1(number, arg1)					\
+({									\
+    TYPEFY (arg1, __arg1) = ARGIFY (arg1);			 	\
+    unsigned long int res = junction_syscall1 (number, __arg1); \
+    (long int) res;						\
+})
+#else
 #define internal_syscall1(number, arg1)					\
 ({									\
     unsigned long int resultvar;					\
@@ -263,8 +282,18 @@
     : "memory", REGISTERS_CLOBBERED_BY_SYSCALL);			\
     (long int) resultvar;						\
 })
+#endif
 
 #undef internal_syscall2
+#if IS_IN(libc)
+#define internal_syscall2(number, arg1, arg2)				\
+({									\
+    TYPEFY (arg2, __arg2) = ARGIFY (arg2);			 	\
+    TYPEFY (arg1, __arg1) = ARGIFY (arg1);			 	\
+    unsigned long int res = junction_syscall2 (number, __arg1, __arg2); \
+    (long int) res;						\
+})
+#else
 #define internal_syscall2(number, arg1, arg2)				\
 ({									\
     unsigned long int resultvar;					\
@@ -279,8 +308,19 @@
     : "memory", REGISTERS_CLOBBERED_BY_SYSCALL);			\
     (long int) resultvar;						\
 })
+#endif
 
 #undef internal_syscall3
+#if IS_IN(libc)
+#define internal_syscall3(number, arg1, arg2, arg3)			\
+({									\
+    TYPEFY (arg3, __arg3) = ARGIFY (arg3);			 	\
+    TYPEFY (arg2, __arg2) = ARGIFY (arg2);			 	\
+    TYPEFY (arg1, __arg1) = ARGIFY (arg1);			 	\
+    unsigned long int res = junction_syscall3 (number, __arg1, __arg2, __arg3); \
+    (long int) res;						\
+})
+#else
 #define internal_syscall3(number, arg1, arg2, arg3)			\
 ({									\
     unsigned long int resultvar;					\
@@ -297,8 +337,20 @@
     : "memory", REGISTERS_CLOBBERED_BY_SYSCALL);			\
     (long int) resultvar;						\
 })
+#endif
 
 #undef internal_syscall4
+#if IS_IN(libc)
+#define internal_syscall4(number, arg1, arg2, arg3, arg4)		\
+({									\
+    TYPEFY (arg4, __arg4) = ARGIFY (arg4);			 	\
+    TYPEFY (arg3, __arg3) = ARGIFY (arg3);			 	\
+    TYPEFY (arg2, __arg2) = ARGIFY (arg2);			 	\
+    TYPEFY (arg1, __arg1) = ARGIFY (arg1);			 	\
+    unsigned long int res = junction_syscall4 (number, __arg1, __arg2, __arg3, __arg4); \
+    (long int) res;						\
+})
+#else
 #define internal_syscall4(number, arg1, arg2, arg3, arg4)		\
 ({									\
     unsigned long int resultvar;					\
@@ -317,8 +369,21 @@
     : "memory", REGISTERS_CLOBBERED_BY_SYSCALL);			\
     (long int) resultvar;						\
 })
+#endif
 
 #undef internal_syscall5
+#if IS_IN(libc)
+#define internal_syscall5(number, arg1, arg2, arg3, arg4, arg5)	\
+({									\
+    TYPEFY (arg5, __arg5) = ARGIFY (arg5);			 	\
+    TYPEFY (arg4, __arg4) = ARGIFY (arg4);			 	\
+    TYPEFY (arg3, __arg3) = ARGIFY (arg3);			 	\
+    TYPEFY (arg2, __arg2) = ARGIFY (arg2);			 	\
+    TYPEFY (arg1, __arg1) = ARGIFY (arg1);			 	\
+    unsigned long int res = junction_syscall5 (number, __arg1, __arg2, __arg3, __arg4, __arg5); \
+    (long int) res;						\
+})
+#else
 #define internal_syscall5(number, arg1, arg2, arg3, arg4, arg5)	\
 ({									\
     unsigned long int resultvar;					\
@@ -340,8 +405,22 @@
     : "memory", REGISTERS_CLOBBERED_BY_SYSCALL);			\
     (long int) resultvar;						\
 })
+#endif
 
 #undef internal_syscall6
+#if IS_IN(libc)
+#define internal_syscall6(number, arg1, arg2, arg3, arg4, arg5, arg6) \
+({									\
+    TYPEFY (arg6, __arg6) = ARGIFY (arg6);			 	\
+    TYPEFY (arg5, __arg5) = ARGIFY (arg5);			 	\
+    TYPEFY (arg4, __arg4) = ARGIFY (arg4);			 	\
+    TYPEFY (arg3, __arg3) = ARGIFY (arg3);			 	\
+    TYPEFY (arg2, __arg2) = ARGIFY (arg2);			 	\
+    TYPEFY (arg1, __arg1) = ARGIFY (arg1);			 	\
+    unsigned long int res = junction_syscall6 (number, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6); \
+    (long int) res;						\
+})
+#else
 #define internal_syscall6(number, arg1, arg2, arg3, arg4, arg5, arg6) \
 ({									\
     unsigned long int resultvar;					\
@@ -365,6 +444,7 @@
     : "memory", REGISTERS_CLOBBERED_BY_SYSCALL);			\
     (long int) resultvar;						\
 })
+#endif
 
 
 # define VDSO_NAME  "LINUX_2.6"
-- 
2.25.1
