From 5843034a44865959436e77d3161045e027520543 Mon Sep 17 00:00:00 2001
From: Josh Fried <joshuafried@gmail.com>
Date: Wed, 4 Oct 2023 21:33:11 +0000
Subject: [PATCH 29/31] make TCP/UDP sockets interruptible

---
 runtime/net/tcp.c   | 53 +++++++++++++++++++++++++++++++++++----------
 runtime/net/tcp.h   |  4 ++--
 runtime/net/udp.c   | 12 ++++++++--
 runtime/net/waitq.h | 37 ++++++++++++++++++++++++++-----
 4 files changed, 85 insertions(+), 21 deletions(-)

diff --git a/runtime/net/tcp.c b/runtime/net/tcp.c
index 035df38..1958dcd 100644
--- a/runtime/net/tcp.c
+++ b/runtime/net/tcp.c
@@ -572,6 +572,7 @@ int tcp_listen(struct netaddr laddr, int backlog, tcpqueue_t **q_out)
  */
 int tcp_accept(tcpqueue_t *q, tcpconn_t **c_out)
 {
+	int ret;
 	tcpconn_t *c;
 
 	spin_lock_np(&q->l);
@@ -581,7 +582,11 @@ int tcp_accept(tcpqueue_t *q, tcpconn_t **c_out)
 			spin_unlock_np(&q->l);
 			return -EAGAIN;
 		}
-		waitq_wait(&q->wq, &q->l);
+		ret = waitq_wait(&q->wq, &q->l);
+		if (unlikely(ret)) {
+			spin_unlock_np(&q->l);
+			return ret;
+		}
 	}
 
 	/* was the queue drained and shutdown? */
@@ -611,6 +616,7 @@ static void __tcp_qshutdown(tcpqueue_t *q)
 	BUG_ON(q->shutdown);
 	q->shutdown = true;
 	poll_set(&q->poll_src, POLLRDHUP | POLLHUP | POLLIN);
+
 	spin_unlock_np(&q->l);
 
 	/* prevent ingress receive and error dispatch (after RCU period) */
@@ -717,8 +723,13 @@ static int __tcp_dial(struct netaddr laddr, struct netaddr raddr,
 	}
 
 	/* wait until the connection is established or there is a failure */
-	while (!c->tx_closed && c->pcb.state < TCP_STATE_ESTABLISHED)
-		waitq_wait(&c->tx_wq, &c->lock);
+	while (!c->tx_closed && c->pcb.state < TCP_STATE_ESTABLISHED) {
+		ret = waitq_wait(&c->tx_wq, &c->lock);
+		if (!c->tx_closed && ret) {
+			spin_unlock_np(&c->lock);
+			return ret;
+		}
+	}
 
 	/* check if the connection failed */
 	if (c->tx_closed) {
@@ -849,6 +860,7 @@ struct netaddr tcp_remote_addr(tcpconn_t *c)
 static ssize_t tcp_read_wait(tcpconn_t *c, size_t len,
 			     struct list_head *q, struct mbuf **mout)
 {
+	int ret;
 	struct mbuf *m;
 	size_t readlen = 0;
 	bool do_ack = false;
@@ -862,7 +874,11 @@ static ssize_t tcp_read_wait(tcpconn_t *c, size_t len,
 			spin_unlock_np(&c->lock);
 			return -EAGAIN;
 		}
-		waitq_wait(&c->rx_wq, &c->lock);
+		ret = waitq_wait(&c->rx_wq, &c->lock);
+		if (unlikely(ret)) {
+			spin_unlock_np(&c->lock);
+			return ret;
+		}
 	}
 
 	/* is the socket closed? */
@@ -1065,6 +1081,7 @@ ssize_t tcp_readv(tcpconn_t *c, const struct iovec *iov, int iovcnt)
 
 static int tcp_write_wait(tcpconn_t *c, size_t *winlen)
 {
+	int ret;
 	spin_lock_np(&c->lock);
 
 	/* block until there is an actionable event */
@@ -1081,7 +1098,11 @@ static int tcp_write_wait(tcpconn_t *c, size_t *winlen)
 			spin_unlock_np(&c->lock);
 			return -EAGAIN;
 		}
-		waitq_wait(&c->tx_wq, &c->lock);
+		ret = waitq_wait(&c->tx_wq, &c->lock);
+		if (unlikely(ret)) {
+			spin_unlock_np(&c->lock);
+			return ret;
+		}
 	}
 	c->zero_wnd = false;
 
@@ -1218,7 +1239,7 @@ static void tcp_retransmit(void *arg)
 	spin_lock_np(&c->lock);
 
 	while (c->tx_exclusive && c->pcb.state != TCP_STATE_CLOSED)
-		waitq_wait(&c->tx_wq, &c->lock);
+		waitq_wait_uninterruptible(&c->tx_wq, &c->lock);
 
 	if (c->pcb.state != TCP_STATE_CLOSED) {
 		c->tx_exclusive = true;
@@ -1288,7 +1309,7 @@ void tcp_conn_shutdown_rx(tcpconn_t *c)
 	waitq_release(&c->rx_wq);
 }
 
-static int tcp_conn_shutdown_tx(tcpconn_t *c)
+static int tcp_conn_shutdown_tx(tcpconn_t *c, bool interruptible)
 {
 	int ret;
 
@@ -1303,8 +1324,16 @@ static int tcp_conn_shutdown_tx(tcpconn_t *c)
 		return 0;
 	}
 
-	while (c->tx_exclusive)
-		waitq_wait(&c->tx_wq, &c->lock);
+	while (c->tx_exclusive) {
+		if (interruptible) {
+			ret = waitq_wait(&c->tx_wq, &c->lock);
+			if (ret)
+				return ret;
+		} else {
+			waitq_wait_uninterruptible(&c->tx_wq, &c->lock);
+		}
+	}
+
 	ret = tcp_tx_ctl(c, TCP_FIN | TCP_ACK, NULL);
 	if (unlikely(ret))
 		return ret;
@@ -1342,7 +1371,7 @@ int tcp_shutdown(tcpconn_t *c, int how)
 
 	spin_lock_np(&c->lock);
 	if (tx) {
-		ret = tcp_conn_shutdown_tx(c);
+		ret = tcp_conn_shutdown_tx(c, true);
 		if (ret) {
 			spin_unlock_np(&c->lock);
 			return ret;
@@ -1375,7 +1404,7 @@ void tcp_abort(tcpconn_t *c)
 	tcp_conn_fail(c, ECONNABORTED);
 
 	while (c->tx_exclusive)
-		waitq_wait(&c->tx_wq, &c->lock);
+		waitq_wait_uninterruptible(&c->tx_wq, &c->lock);
 
 	snd_nxt = c->pcb.snd_nxt;
 	spin_unlock_np(&c->lock);
@@ -1396,7 +1425,7 @@ void tcp_close(tcpconn_t *c)
 
 	spin_lock_np(&c->lock);
 	BUG_ON(!waitq_empty(&c->rx_wq));
-	ret = tcp_conn_shutdown_tx(c);
+	ret = tcp_conn_shutdown_tx(c, false);
 	if (ret)
 		tcp_conn_fail(c, -ret);
 	tcp_conn_shutdown_rx(c);
diff --git a/runtime/net/tcp.h b/runtime/net/tcp.h
index 625281b..0c87d75 100644
--- a/runtime/net/tcp.h
+++ b/runtime/net/tcp.h
@@ -6,11 +6,11 @@
 #include <base/list.h>
 #include <base/kref.h>
 #include <base/time.h>
-#include <runtime/sync.h>
-#include <runtime/tcp.h>
 #include <net/tcp.h>
 #include <net/mbuf.h>
 #include <net/mbufq.h>
+#include <runtime/sync.h>
+#include <runtime/tcp.h>
 
 #include "defs.h"
 #include "waitq.h"
diff --git a/runtime/net/udp.c b/runtime/net/udp.c
index 153df4b..d7326ad 100644
--- a/runtime/net/udp.c
+++ b/runtime/net/udp.c
@@ -336,7 +336,11 @@ ssize_t udp_read_from(udpconn_t *c, void *buf, size_t len,
 			spin_unlock_np(&c->inq_lock);
 			return -EAGAIN;
 		}
-		waitq_wait(&c->inq_wq, &c->inq_lock);
+		ret = waitq_wait(&c->inq_wq, &c->inq_lock);
+		if (unlikely(ret)) {
+			spin_unlock_np(&c->inq_lock);
+			return ret;
+		}
 	}
 
 	/* is the socket drained and shutdown? */
@@ -438,7 +442,11 @@ ssize_t udp_write_to(udpconn_t *c, const void *buf, size_t len,
 			spin_unlock_np(&c->outq_lock);
 			return -EAGAIN;
 		}
-		waitq_wait(&c->outq_wq, &c->outq_lock);
+		ret = waitq_wait(&c->outq_wq, &c->outq_lock);
+		if (unlikely(ret)) {
+			spin_unlock_np(&c->outq_lock);
+			return ret;
+		}
 	}
 
 	/* is the socket shutdown? */
diff --git a/runtime/net/waitq.h b/runtime/net/waitq.h
index 17fed7f..00980f7 100644
--- a/runtime/net/waitq.h
+++ b/runtime/net/waitq.h
@@ -8,17 +8,18 @@
 #include <base/list.h>
 #include <runtime/thread.h>
 #include <runtime/sync.h>
+#include <runtime/interruptible_wait.h>
 
 typedef struct waitq {
 	struct list_head	waiters;
 } waitq_t;
 
 /**
- * waitq_wait - waits for the next signal
+ * waitq_wait_uninterruptible - waits for the next signal
  * @q: the wake queue
  * @l: a held spinlock protecting the wake queue and the condition
  */
-static inline void waitq_wait(waitq_t *q, spinlock_t *l)
+static inline void waitq_wait_uninterruptible(waitq_t *q, spinlock_t *l)
 {
 	assert_spin_lock_held(l);
 	list_add_tail(&q->waiters, &thread_self()->link);
@@ -26,6 +27,32 @@ static inline void waitq_wait(waitq_t *q, spinlock_t *l)
 	spin_lock_np(l);
 }
 
+/**
+ * waitq_wait - waits for the next signal
+ * @q: the wake queue
+ * @l: a held spinlock protecting the wake queue and the condition
+ *
+ * Returns 0 if succeeded, or -EINTR if interrupted
+ */
+static inline __must_use_return int waitq_wait(waitq_t *q, spinlock_t *l)
+{
+	thread_t *myth = thread_self();
+	assert_spin_lock_held(l);
+
+	if (prepare_interruptible(myth))
+		return -EINTR;
+
+	list_add_tail(&q->waiters, &myth->link);
+	thread_park_and_unlock_np(l);
+	spin_lock_np(l);
+
+	int status = get_interruptible_status(myth);
+	if (unlikely(status > 1))
+		list_del_from(&q->waiters, &myth->link);
+
+	return status > 0 ? -EINTR : 0;
+}
+
 /**
  * waitq_signal - wakes up to one waiter on the wake queue
  * @q: the wake queue
@@ -47,7 +74,7 @@ static inline thread_t *waitq_signal(waitq_t *q, spinlock_t *l)
 static inline void waitq_signal_finish(thread_t *th)
 {
 	if (th)
-		thread_ready(th);
+		interruptible_wake(th);
 }
 
 /**
@@ -75,7 +102,7 @@ static inline void waitq_release(waitq_t *q)
 		thread_t *th = list_pop(&q->waiters, thread_t, link);
 		if (!th)
 			break;
-		thread_ready(th);
+		interruptible_wake(th);
 	}
 }
 
@@ -90,7 +117,7 @@ static inline void waitq_release_finish(struct list_head *waiters)
 		thread_t *th = list_pop(waiters, thread_t, link);
 		if (!th)
 			break;
-		thread_ready(th);
+		interruptible_wake(th);
 	}
 }
 
-- 
2.34.1

