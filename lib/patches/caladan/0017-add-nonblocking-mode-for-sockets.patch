From f095a0f2337ab17e887381c1ea21cc75264029eb Mon Sep 17 00:00:00 2001
From: Josh Fried <joshuafried@gmail.com>
Date: Tue, 14 Feb 2023 23:00:52 -0500
Subject: [PATCH 17/17] add nonblocking mode for sockets

---
 inc/runtime/tcp.h |  6 ++++
 inc/runtime/udp.h |  1 +
 runtime/net/tcp.c | 92 ++++++++++++++++++++++++++++++++++++++++-------
 runtime/net/tcp.h |  1 +
 runtime/net/udp.c | 29 +++++++++++++--
 5 files changed, 115 insertions(+), 14 deletions(-)

diff --git a/inc/runtime/tcp.h b/inc/runtime/tcp.h
index e0c5482..b3e5df1 100644
--- a/inc/runtime/tcp.h
+++ b/inc/runtime/tcp.h
@@ -16,14 +16,20 @@ typedef struct tcpconn tcpconn_t;
 
 extern int tcp_dial(struct netaddr laddr, struct netaddr raddr,
 		    tcpconn_t **c_out);
+extern int tcp_dial_nonblocking(struct netaddr laddr, struct netaddr raddr,
+	                            tcpconn_t **c_out);
 extern int tcp_dial_affinity(uint32_t affinity, struct netaddr raddr,
 		    tcpconn_t **c_out);
 extern int tcp_dial_conn_affinity(tcpconn_t *in, struct netaddr raddr,
 		    tcpconn_t **c_out);
+
+extern void tcp_set_nonblocking(tcpconn_t *c, bool nonblocking);
+
 extern int tcp_listen(struct netaddr laddr, int backlog, tcpqueue_t **q_out);
 extern int tcp_accept(tcpqueue_t *q, tcpconn_t **c_out);
 extern void tcp_qshutdown(tcpqueue_t *q);
 extern void tcp_qclose(tcpqueue_t *q);
+extern void tcpq_set_nonblocking(tcpqueue_t *q, bool nonblocking);
 extern struct netaddr tcp_local_addr(tcpconn_t *c);
 extern struct netaddr tcp_remote_addr(tcpconn_t *c);
 extern ssize_t tcp_read(tcpconn_t *c, void *buf, size_t len);
diff --git a/inc/runtime/udp.h b/inc/runtime/udp.h
index 31df911..350109b 100644
--- a/inc/runtime/udp.h
+++ b/inc/runtime/udp.h
@@ -52,6 +52,7 @@ extern void udp_close(udpconn_t *c);
 extern void udp_poll_install_cb(udpconn_t *c, poll_notif_fn_t setfn,
 			                    poll_notif_fn_t clearfn, unsigned long data);
 
+extern void udp_set_nonblocking(udpconn_t *c, bool nonblocking);
 
 /*
  * UDP Parallel API
diff --git a/runtime/net/tcp.c b/runtime/net/tcp.c
index 766e679..199037a 100644
--- a/runtime/net/tcp.c
+++ b/runtime/net/tcp.c
@@ -198,6 +198,7 @@ void tcp_conn_set_state(tcpconn_t *c, int new_state)
 	if (c->pcb.state < TCP_STATE_ESTABLISHED &&
 	    new_state >= TCP_STATE_ESTABLISHED) {
 		waitq_release(&c->tx_wq);
+		poll_set(&c->poll_src, POLLOUT);
 	}
 
 	tcp_debug_state_change(c, c->pcb.state, new_state);
@@ -254,6 +255,7 @@ tcpconn_t *tcp_conn_alloc(void)
 	/* general fields */
 	memset(&c->pcb, 0, sizeof(c->pcb));
 	spin_lock_init(&c->lock);
+	c->nonblocking = false;
 	kref_init(&c->ref);
 	c->err = 0;
 
@@ -391,6 +393,7 @@ struct tcpqueue {
 	struct list_head	conns;
 	int			backlog;
 	bool			shutdown;
+	bool			nonblocking;
 
 	poll_source_t	poll_src;
 
@@ -483,6 +486,7 @@ int tcp_listen(struct netaddr laddr, int backlog, tcpqueue_t **q_out)
 	list_head_init(&q->conns);
 	q->backlog = backlog;
 	q->shutdown = false;
+	q->nonblocking = false;
 	kref_init(&q->ref);
 
 	q->poll_src.set_fn = NULL;
@@ -517,8 +521,14 @@ int tcp_accept(tcpqueue_t *q, tcpconn_t **c_out)
 	tcpconn_t *c;
 
 	spin_lock_np(&q->l);
-	while (list_empty(&q->conns) && !q->shutdown)
+
+	while (list_empty(&q->conns) && !q->shutdown) {
+		if (q->nonblocking) {
+			spin_unlock_np(&q->l);
+			return -EAGAIN;
+		}
 		waitq_wait(&q->wq, &q->l);
+	}
 
 	/* was the queue drained and shutdown? */
 	if (list_empty(&q->conns) && q->shutdown) {
@@ -603,15 +613,8 @@ void tcp_qclose(tcpqueue_t *q)
  * Support for the TCP socket API
  */
 
-/**
- * tcp_dial - opens a TCP connection, creating a new socket
- * @laddr: the local address
- * @raddr: the remote address
- * @c_out: a pointer to store the new connection
- *
- * Returns 0 if successful, otherwise fail.
- */
-int tcp_dial(struct netaddr laddr, struct netaddr raddr, tcpconn_t **c_out)
+static int __tcp_dial(struct netaddr laddr, struct netaddr raddr,
+	                  tcpconn_t **c_out, bool nonblocking)
 {
 	struct tcp_options opts;
 	tcpconn_t *c;
@@ -622,6 +625,8 @@ int tcp_dial(struct netaddr laddr, struct netaddr raddr, tcpconn_t **c_out)
 	if (unlikely(!c))
 		return -ENOMEM;
 
+	c->nonblocking = nonblocking;
+
 	/* rewrite loopback address */
 	if (raddr.ip == MAKE_IP_ADDR(127, 0, 0, 1))
 		raddr.ip = netcfg.addr;
@@ -651,6 +656,12 @@ int tcp_dial(struct netaddr laddr, struct netaddr raddr, tcpconn_t **c_out)
 	tcp_conn_get(c); /* take a ref for the state machine */
 	tcp_conn_set_state(c, TCP_STATE_SYN_SENT);
 
+	if (c->nonblocking) {
+		spin_unlock_np(&c->lock);
+		*c_out = c;
+		return -EINPROGRESS;
+	}
+
 	/* wait until the connection is established or there is a failure */
 	while (!c->tx_closed && c->pcb.state < TCP_STATE_ESTABLISHED)
 		waitq_wait(&c->tx_wq, &c->lock);
@@ -668,6 +679,34 @@ int tcp_dial(struct netaddr laddr, struct netaddr raddr, tcpconn_t **c_out)
 	return 0;
 }
 
+/**
+ * tcp_dial - opens a TCP connection, creating a new socket
+ * @laddr: the local address
+ * @raddr: the remote address
+ * @c_out: a pointer to store the new connection
+ *
+ * Returns 0 if successful, otherwise fail.
+ */
+int tcp_dial(struct netaddr laddr, struct netaddr raddr, tcpconn_t **c_out)
+{
+	return __tcp_dial(laddr, raddr, c_out, false);
+}
+
+/**
+ * tcp_dial_nonblocking - opens a nonblocking TCP connection, creating a new
+ * socket
+ * @laddr: the local address
+ * @raddr: the remote address
+ * @c_out: a pointer to store the new connection
+ *
+ * Returns 0 if successful, otherwise fail.
+ */
+int tcp_dial_nonblocking(struct netaddr laddr, struct netaddr raddr,
+	                     tcpconn_t **c_out)
+{
+	return __tcp_dial(laddr, raddr, c_out, true);
+}
+
 /**
  * tcp_dial_conn_affinity - opens a TCP connection with matching
  * kthread affinity to another socket
@@ -764,8 +803,13 @@ static ssize_t tcp_read_wait(tcpconn_t *c, size_t len,
 	spin_lock_np(&c->lock);
 
 	/* block until there is an actionable event */
-	while (!c->rx_closed && (c->rx_exclusive || list_empty(&c->rxq)))
+	while (!c->rx_closed && (c->rx_exclusive || list_empty(&c->rxq))) {
+		if (c->nonblocking) {
+			spin_unlock_np(&c->lock);
+			return -EAGAIN;
+		}
 		waitq_wait(&c->rx_wq, &c->lock);
+	}
 
 	/* is the socket closed? */
 	if (c->rx_closed) {
@@ -979,6 +1023,10 @@ static int tcp_write_wait(tcpconn_t *c, size_t *winlen)
 			c->zero_wnd_ts = microtime();
 			tcp_timer_update(c);
 		}
+		if (c->nonblocking) {
+			spin_unlock_np(&c->lock);
+			return -EAGAIN;
+		}
 		waitq_wait(&c->tx_wq, &c->lock);
 	}
 	c->zero_wnd = false;
@@ -1313,7 +1361,7 @@ void tcp_poll_install_cb(tcpconn_t *c, poll_notif_fn_t setfn,
 	c->poll_src.clear_fn = clearfn;
 	c->poll_src.poller_data = data;
 
-	if (!tcp_is_snd_full(c))
+	if (c->pcb.state == TCP_STATE_ESTABLISHED && !tcp_is_snd_full(c))
 		flags |= POLLOUT;
 
 	if (!list_empty(&c->rxq))
@@ -1351,6 +1399,26 @@ void tcpq_poll_install_cb(tcpqueue_t *q, poll_notif_fn_t setfn,
 	spin_unlock_np(&q->l);
 }
 
+void tcp_set_nonblocking(tcpconn_t *c, bool nonblocking)
+{
+	spin_lock_np(&c->lock);
+	c->nonblocking = nonblocking;
+	if (nonblocking) {
+		waitq_release(&c->tx_wq);
+		waitq_release(&c->rx_wq);
+	}
+	spin_unlock_np(&c->lock);
+}
+
+void tcpq_set_nonblocking(tcpqueue_t *q, bool nonblocking)
+{
+	spin_lock_np(&q->l);
+	q->nonblocking = nonblocking;
+	if (nonblocking)
+		waitq_release(&q->wq);
+	spin_unlock_np(&q->l);
+}
+
 
 /**
  * tcp_init_late - starts the TCP worker thread
diff --git a/runtime/net/tcp.h b/runtime/net/tcp.h
index c5a4e65..93fcadf 100644
--- a/runtime/net/tcp.h
+++ b/runtime/net/tcp.h
@@ -87,6 +87,7 @@ struct tcpconn {
 	struct list_node	global_link;
 	struct list_node	queue_link;
 	spinlock_t		lock;
+	bool			nonblocking;
 	struct kref		ref;
 	int			err; /* error code for read(), write(), etc. */
 	uint32_t		winmax; /* initial receive window size */
diff --git a/runtime/net/udp.c b/runtime/net/udp.c
index c9868fc..e79e633 100644
--- a/runtime/net/udp.c
+++ b/runtime/net/udp.c
@@ -49,6 +49,7 @@ static int udp_send_raw(struct mbuf *m, size_t len,
 struct udpconn {
 	struct trans_entry	e;
 	bool			shutdown;
+	bool			nonblocking;
 
 	/* ingress support */
 	spinlock_t		inq_lock;
@@ -132,6 +133,7 @@ static const struct trans_ops udp_conn_ops = {
 static void udp_init_conn(udpconn_t *c)
 {
 	c->shutdown = false;
+	c->nonblocking = false;
 
 	/* initialize ingress fields */
 	spin_lock_init(&c->inq_lock);
@@ -329,8 +331,13 @@ ssize_t udp_read_from(udpconn_t *c, void *buf, size_t len,
 	spin_lock_np(&c->inq_lock);
 
 	/* block until there is an actionable event */
-	while (mbufq_empty(&c->inq) && !c->inq_err && !c->shutdown)
+	while (mbufq_empty(&c->inq) && !c->inq_err && !c->shutdown) {
+		if (c->nonblocking) {
+			spin_unlock_np(&c->inq_lock);
+			return -EAGAIN;
+		}
 		waitq_wait(&c->inq_wq, &c->inq_lock);
+	}
 
 	/* is the socket drained and shutdown? */
 	if (mbufq_empty(&c->inq) && c->shutdown) {
@@ -426,8 +433,13 @@ ssize_t udp_write_to(udpconn_t *c, const void *buf, size_t len,
 	spin_lock_np(&c->outq_lock);
 
 	/* block until there is an actionable event */
-	while (c->outq_len >= c->outq_cap && !c->shutdown)
+	while (c->outq_len >= c->outq_cap && !c->shutdown) {
+		if (c->nonblocking) {
+			spin_unlock_np(&c->outq_lock);
+			return -EAGAIN;
+		}
 		waitq_wait(&c->outq_wq, &c->outq_lock);
+	}
 
 	/* is the socket shutdown? */
 	if (c->shutdown) {
@@ -568,6 +580,19 @@ void udp_close(udpconn_t *c)
 		udp_conn_put(c);
 }
 
+void udp_set_nonblocking(udpconn_t *c, bool nonblocking)
+{
+	spin_lock_np(&c->outq_lock);
+	spin_lock(&c->inq_lock);
+	c->nonblocking = nonblocking;
+	if (nonblocking) {
+		waitq_release(&c->inq_wq);
+		waitq_release(&c->outq_wq);
+	}
+	spin_unlock(&c->inq_lock);
+	spin_unlock_np(&c->outq_lock);
+}
+
 void udp_poll_install_cb(udpconn_t *c, poll_notif_fn_t setfn,
 			                    poll_notif_fn_t clearfn, unsigned long data)
 {
-- 
2.37.2

