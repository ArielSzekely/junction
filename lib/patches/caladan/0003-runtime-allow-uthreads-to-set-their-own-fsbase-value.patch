From 6e09d4c994ac7b94942e2832f0f4fc3094382fc6 Mon Sep 17 00:00:00 2001
From: Josh Fried <joshuafried@gmail.com>
Date: Thu, 8 Dec 2022 15:05:23 -0500
Subject: [PATCH 03/28] runtime: allow uthreads to set their own fsbase values

---
 build/shared.mk      |  2 +-
 inc/asm/ops.h        |  6 ++++++
 inc/runtime/thread.h | 14 ++++++++++++--
 runtime/defs.h       | 10 ++++++----
 runtime/sched.c      | 40 +++++++++++++++++++++++++++++++++-------
 runtime/switch.S     |  3 +++
 6 files changed, 61 insertions(+), 14 deletions(-)

diff --git a/build/shared.mk b/build/shared.mk
index 1e087d8b..1d5bc4ea 100644
--- a/build/shared.mk
+++ b/build/shared.mk
@@ -9,7 +9,7 @@ include $(ROOT_PATH)/build/config
 
 # shared toolchain definitions
 INC = -I$(ROOT_PATH)/inc
-FLAGS  = -g -Wall -D_GNU_SOURCE $(INC)
+FLAGS  = -g -Wall -D_GNU_SOURCE $(INC) -mfsgsbase
 LDFLAGS = -T $(ROOT_PATH)/base/base.ld
 LD      = gcc
 CC      = gcc
diff --git a/inc/asm/ops.h b/inc/asm/ops.h
index f07f2204..98ed53b8 100644
--- a/inc/asm/ops.h
+++ b/inc/asm/ops.h
@@ -4,6 +4,7 @@
 
 #pragma once
 
+#include <immintrin.h>
 #include <features.h>
 #include <base/types.h>
 
@@ -33,6 +34,11 @@ static inline void cpuid(int leaf, struct cpuid_info *regs)
 	asm volatile("cpuid" : "=a" (regs->eax), "=b" (regs->ebx), "=c" (regs->ecx), "=d" (regs->edx) : "a" (leaf));
 }
 
+static inline void set_fsbase(uint64_t val)
+{
+	_writefsbase_u64(val);
+}
+
 static inline uint64_t rdtsc(void)
 {
 #if __GNUC_PREREQ(10, 0)
diff --git a/inc/runtime/thread.h b/inc/runtime/thread.h
index d71d30f1..c653e681 100644
--- a/inc/runtime/thread.h
+++ b/inc/runtime/thread.h
@@ -26,9 +26,13 @@ extern void thread_ready(thread_t *thread);
 extern void thread_ready_head(thread_t *thread);
 extern thread_t *thread_create(thread_fn_t fn, void *arg);
 extern thread_t *thread_create_with_buf(thread_fn_t fn, void **buf, size_t len);
+extern void __set_uthread_specific(thread_t *th, uint64_t val);
+extern uint64_t __get_uthread_specific(thread_t *th);
+extern void thread_set_fsbase(thread_t *th, uint64_t fsbase);
 
 DECLARE_PERTHREAD(thread_t *, __self);
 DECLARE_PERTHREAD(unsigned int, kthread_idx);
+DECLARE_PERTHREAD(uint64_t, runtime_fsbase);
 
 static inline unsigned int get_current_affinity(void)
 {
@@ -43,9 +47,15 @@ inline thread_t *thread_self(void)
 	return perthread_read_stable(__self);
 }
 
+static inline uint64_t get_uthread_specific(void)
+{
+    return __get_uthread_specific(thread_self());
+}
 
-extern uint64_t get_uthread_specific(void);
-extern void set_uthread_specific(uint64_t val);
+static inline void set_uthread_specific(uint64_t val)
+{
+    __set_uthread_specific(thread_self(), val);
+}
 
 
 /*
diff --git a/runtime/defs.h b/runtime/defs.h
index 58df7144..18c1f5ce 100644
--- a/runtime/defs.h
+++ b/runtime/defs.h
@@ -72,6 +72,7 @@ struct thread_tf {
 	uint64_t rax;	/* holds return value */
 	uint64_t rip;	/* instruction pointer */
 	uint64_t rsp;	/* stack pointer */
+	uint64_t fsbase; /* holds %fs */
 };
 
 #define ARG0(tf)        ((tf)->rdi)
@@ -93,6 +94,7 @@ struct thread {
 	struct list_node	link;
 	struct stack		*stack;
 	unsigned int		main_thread:1;
+	unsigned int		has_fsbase:1;
 	unsigned int		thread_ready;
 	unsigned int		thread_running;
 	unsigned int		last_cpu;
@@ -140,10 +142,10 @@ DECLARE_PERTHREAD(struct tcache_perthread, stack_pt);
  */
 static inline struct stack *stack_alloc(void)
 {
-	void *s = tcache_alloc(perthread_ptr(stack_pt));
-	if (unlikely(!s))
+	void *p = tcache_alloc(perthread_ptr(stack_pt));
+	if (unlikely(!p))
 		return NULL;
-	return container_of(s, struct stack, usable);
+	return container_of((uintptr_t (*)[STACK_PTR_SIZE])p, struct stack, usable);
 }
 
 /**
@@ -258,7 +260,7 @@ static inline bool hardware_q_pending(struct hardware_q *q)
 	tail = ACCESS_ONCE(*q->consumer_idx);
 	idx = tail & (q->nr_descriptors - 1);
 	parity = !!(tail & q->nr_descriptors);
-	addr = q->descriptor_table +
+	addr = (unsigned char *)q->descriptor_table +
 		     (idx << q->descriptor_log_size) + q->parity_byte_offset;
 	hd_parity = !!(ACCESS_ONCE(*addr) & q->parity_bit_mask);
 
diff --git a/runtime/sched.c b/runtime/sched.c
index 3a82ca52..4e1d37e3 100644
--- a/runtime/sched.c
+++ b/runtime/sched.c
@@ -3,6 +3,7 @@
  */
 
 #include <sched.h>
+#include <immintrin.h>
 
 #include <base/stddef.h>
 #include <base/lock.h>
@@ -21,7 +22,7 @@
 DEFINE_PERTHREAD(thread_t *, __self);
 /* a pointer to the top of the per-kthread (TLS) runtime stack */
 static DEFINE_PERTHREAD(void *, runtime_stack);
-
+DEFINE_PERTHREAD(uint64_t, runtime_fsbase);
 /* Flag to prevent watchdog from running */
 bool disable_watchdog;
 
@@ -43,16 +44,23 @@ static DEFINE_PERTHREAD(uint64_t, last_tsc);
  */
 thread_t *thread_self(void);
 
-uint64_t get_uthread_specific(void)
+uint64_t __get_uthread_specific(thread_t *th)
+{
+	return th->tlsvar;
+}
+
+void __set_uthread_specific(thread_t *th, uint64_t val)
 {
-	BUG_ON(!perthread_read_stable(__self));
-	return (perthread_read_stable(__self))->tlsvar;
+	th->tlsvar = val;
 }
 
-void set_uthread_specific(uint64_t val)
+void thread_set_fsbase(thread_t *th, uint64_t fsbase)
 {
-	BUG_ON(!perthread_read_stable(__self));
-	(perthread_read_stable(__self))->tlsvar = val;
+	th->tf.fsbase = fsbase;
+	barrier();
+	th->has_fsbase = true;
+	if (thread_self() == th)
+		set_fsbase(fsbase);
 }
 
 /**
@@ -85,6 +93,12 @@ static __noreturn void jmp_thread(thread_t *th)
 		while (load_acquire(&th->thread_running))
 			cpu_relax();
 	}
+
+	if (!th->has_fsbase)
+		th->tf.fsbase = perthread_read(runtime_fsbase);
+
+	set_fsbase(th->tf.fsbase);
+
 	th->thread_running = true;
 	__jmp_thread(&th->tf);
 }
@@ -109,6 +123,12 @@ static void jmp_thread_direct(thread_t *oldth, thread_t *newth)
 		while (load_acquire(&newth->thread_running))
 			cpu_relax();
 	}
+
+	if (!newth->has_fsbase)
+		newth->tf.fsbase = perthread_read(runtime_fsbase);
+
+	set_fsbase(newth->tf.fsbase);
+
 	newth->thread_running = true;
 	__jmp_thread_direct(&oldth->tf, &newth->tf, &oldth->thread_running);
 }
@@ -128,6 +148,8 @@ static void jmp_runtime(runtime_fn_t fn)
 	assert_preempt_disabled();
 	assert(thread_self() != NULL);
 
+	set_fsbase(perthread_read(runtime_fsbase));
+
 	__jmp_runtime(&thread_self()->tf, fn, perthread_read(runtime_stack));
 }
 
@@ -140,6 +162,7 @@ static __noreturn void jmp_runtime_nosave(runtime_fn_t fn)
 {
 	assert_preempt_disabled();
 
+	set_fsbase(perthread_read(runtime_fsbase));
 	__jmp_runtime_nosave(fn, perthread_read(runtime_stack));
 }
 
@@ -797,8 +820,10 @@ static __always_inline thread_t *__thread_create(void)
 
 	th->stack = s;
 	th->main_thread = false;
+	th->has_fsbase = false;
 	th->thread_ready = false;
 	th->thread_running = false;
+	th->tlsvar = 0;
 
 	return th;
 }
@@ -974,6 +999,7 @@ int sched_init_thread(void)
 		return -ENOMEM;
 
 	perthread_store(runtime_stack, (void *)stack_init_to_rsp(s, runtime_top_of_stack));
+	perthread_store(runtime_fsbase, _readfsbase_u64());
 
 	return 0;
 }
diff --git a/runtime/switch.S b/runtime/switch.S
index fbca8606..054ffed0 100644
--- a/runtime/switch.S
+++ b/runtime/switch.S
@@ -36,6 +36,7 @@
 #define RAX	(112)	/* return code */
 #define RIP	(120)	/* instruction pointer */
 #define RSP	(128)	/* stack pointer */
+#define FSBASE	(136)	/* fsbase */
 
 /**
  * __jmp_thread - executes a thread from the runtime
@@ -158,6 +159,7 @@ __jmp_thread_direct:
  * @tf: the struct thread_tf to save state (%rdi)
  * @fn: the function pointer to call (%rsi)
  * @stack: the start of the runtime stack (%rdx)
+ * @fsbase: the fs base register (%rcx)
  *
  * This low-level variant isn't intended to be called directly.
  * Must be called with preemption disabled.
@@ -192,6 +194,7 @@ __jmp_runtime:
  *			  current stack frame
  * @fn: the function pointer to call (%rdi)
  * @stack: the start of the runtime stack (%rsi)
+ * @fsbase: the fs base register (%rdx)
  *
  * This low-level variant isn't intended to be called directly.
  * Must be called with preemption disabled.
-- 
2.39.2

